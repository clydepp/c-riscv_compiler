digraph AST {
    node [shape=box, fontname="Courier", fontsize=10];

    // Root node: function_definition
    function_definition [label="function_definition"];
    declaration_specifiers [label="declaration_specifiers: INT"];
    declarator [label="declarator"];
    compound_statement [label="compound_statement"];

    // function_definition structure
    function_definition -> declaration_specifiers;
    function_definition -> declarator;
    function_definition -> compound_statement;

    // declarator: DirectDeclarator for function name 'f'
    direct_declarator [label="direct_declarator: IDENTIFIER(f)"];
    declarator -> direct_declarator;

    // compound_statement: Body of the function
    statement_list [label="statement_list"];
    compound_statement -> statement_list;

    // statement_list: Contains two statements
    declaration [label="declaration"];
    jump_statement [label="jump_statement: return"];
    statement_list -> declaration;
    statement_list -> jump_statement;

    // declaration: int x = 1;
    declaration_specifiers2 [label="declaration_specifiers: INT"];
    init_declarator_list [label="init_declarator_list"];
    declaration -> declaration_specifiers2;
    declaration -> init_declarator_list;

    // init_declarator_list: Variable declaration
    init_declarator [label="init_declarator"];
    init_declarator_list -> init_declarator;

    // init_declarator: x = 1
    declarator2 [label="declarator"];
    initializer [label="initializer: assignment_expression"];
    init_declarator -> declarator2;
    init_declarator -> initializer;

    // declarator2: DirectDeclarator for variable name 'x'
    direct_declarator2 [label="direct_declarator: IDENTIFIER(x)"];
    declarator2 -> direct_declarator2;

    // initializer: assignment_expression for '1'
    assignment_expression [label="assignment_expression"];
    conditional_expression [label="conditional_expression"];
    logical_or_expression [label="logical_or_expression"];
    logical_and_expression [label="logical_and_expression"];
    inclusive_or_expression [label="inclusive_or_expression"];
    exclusive_or_expression [label="exclusive_or_expression"];
    and_expression [label="and_expression"];
    equality_expression [label="equality_expression"];
    relational_expression [label="relational_expression"];
    shift_expression [label="shift_expression"];
    additive_expression [label="additive_expression"];
    multiplicative_expression [label="multiplicative_expression"];
    cast_expression [label="cast_expression"];
    unary_expression [label="unary_expression"];
    postfix_expression [label="postfix_expression"];
    primary_expression [label="primary_expression: INT_CONSTANT(1)"];

    initializer -> assignment_expression;
    assignment_expression -> conditional_expression;
    conditional_expression -> logical_or_expression;
    logical_or_expression -> logical_and_expression;
    logical_and_expression -> inclusive_or_expression;
    inclusive_or_expression -> exclusive_or_expression;
    exclusive_or_expression -> and_expression;
    and_expression -> equality_expression;
    equality_expression -> relational_expression;
    relational_expression -> shift_expression;
    shift_expression -> additive_expression;
    additive_expression -> multiplicative_expression;
    multiplicative_expression -> cast_expression;
    cast_expression -> unary_expression;
    unary_expression -> postfix_expression;
    postfix_expression -> primary_expression;

    // jump_statement: return x + 1;
    expression [label="expression"];
    jump_statement -> expression;

    // expression: x + 1
    assignment_expression2 [label="assignment_expression"];
    expression -> assignment_expression2;

    // assignment_expression2: x + 1
    additive_expression2 [label="additive_expression"];
    assignment_expression2 -> additive_expression2;

    // additive_expression2: x + 1
    multiplicative_expression2 [label="multiplicative_expression"];
    additive_expression2 -> multiplicative_expression2;
    additive_expression2 -> additive_operator [label="+"];
    additive_expression2 -> multiplicative_expression3 [label="multiplicative_expression"];

    // multiplicative_expression2: x
    cast_expression2 [label="cast_expression"];
    multiplicative_expression2 -> cast_expression2;
    cast_expression2 -> unary_expression2 [label="unary_expression"];
    unary_expression2 -> postfix_expression2 [label="postfix_expression"];
    postfix_expression2 -> primary_expression2 [label="primary_expression: IDENTIFIER(x)"];

    // multiplicative_expression3: 1
    cast_expression3 [label="cast_expression"];
    multiplicative_expression3 -> cast_expression3;
    cast_expression3 -> unary_expression3 [label="unary_expression"];
    unary_expression3 -> postfix_expression3 [label="postfix_expression"];
    postfix_expression3 -> primary_expression3 [label="primary_expression: INT_CONSTANT(1)"];
}
